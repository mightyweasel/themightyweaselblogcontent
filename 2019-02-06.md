# Coding is to Programming...
## What are we even talking about really?

Have you even seen a great white shark about to attack? Broaches he surface and eyes roll back into their heads. Mouth agape? 

Yup. As a developer you've seen this look. It happens every time you try to explain what "development" or "coding" or "programming" means, or how one thing is connected to another. You probably end up getting lost in some rabbit hole and then some argument with another dev about "technical correctness" or some dogmatic standpoint arrived to after years of miring in a tarpit somewhere.

The problem is, it's entirely our fault. Techies I mean.  We are the source of and ironically solution to all of our problems.

This shark is being told what a toolchain is for hotloading front ends in a dev context. Note glassy eyes.

A non-techie friend of mine recently asked me about how TECHIE_TERM_A was related to TECHIE_TERM_B. And hoo boy, every one of those questions is loaded (and then overloaded)

The reason we techies always seem to fail at explaining things are a few fold:

1. Most techies don't want to ruffle your feathers
2. Most techies don't remember how hard it was to learn to wherever point they are at now
3. Most techies learn from other techies, and have to ride the line between "the dev is keen on learning" and "this dev doesn't know squat"
4. Most techies really do want non-techies to understand what we do
5. Most techies have a hard time boiling it down to make sense for humans

But why?!

Because it's honestly magic, and we all understand enough to get by and build you all magical things. But the corollary is, it's baud rammed magic, and we barely understand it all anymore. We have a term called a Heisenbug, no I'm not lying, its a real/not-real thing. We have duck-debugging, because why wouldn't you talk out loud to yourself about the code you yourself just wrote so that you can critique it find mistakes berate yourself agree with yourself thank yourself for the input and then continue fixing bugs.

Because that is the model of a normal human operation right?

Weasel.headTilt("?");

I think we're all coming at this the wrong way. Everyone is either in a Dunning-Krueger or an Impostor-Syndrome, so I want to strip it way back.

Let's learn what the words mean together. I'm going to assume you know as much as me, which is to say

"You know you a lot about a lot, and you know that sums to a goose toque above nothing compared to what there is to learn"

So let's get started:

I'm going to focus on the common word "Coding". We all know someone who codes. Let me help you understand what that might mean.

When you Code, you're also Programming, and Developing. Because they're the same thing. Just different eras. "Tubular man!" vs. "Dat sik bruh!" vs. "100"

Why so many words? Because variety is the spice of life. Also, to sound cool.

When you Code, you're writing Code. Code is written in a Language.

Now things are going to get dicey. I know, you're thinking: But I use language every day, I might even be bilingual or trilingual! It's not hard.

True. But at the base of it, all human spoken language is built on top of noises we can make. So the root of it all the same, at least if you aren't human.

Languages as far as programming goes, are the written spells and incancations that make machines to machine magic. But let's stop for a sec. 

Put on your machine-hat.

Machines have a language too, one that they talk to themselves with. Like your own inner voice that tells you to do things like "dont hit the snooze button", "you should eat vegetables", "jumping out of this plane is a good idea".

Machines, at their very heart (the CPU, Central Processing Unit, the thing that instructs things to do things on a machine), speak in "machine code". While really is bunches of 1s and 0s in chunks that mean things. These 1s and 0s actual represent the amount of electricity flowing through certain parts (the "logic gates", like AND, OR, NOT, NAND, and more!). 

Like a plinko machine of marbles, just moving at near the speed of light, plugged into your A/C socket.

In the early days of becoming friends with machines (just like we did with canines), humans would speak to machines in a language as close to theirs as we could manage. Punch cards, "assembly". These were the basic instructions the CPU knew how to respond to (SIT, STAY, BARK!), or in this case (LDA, JMP, CMP).

With these basic instructions (and the machine having memory and storage it could lean on to remember and recall things). We were off to the races.

But imagine every time you wanted to talk to your friend, you needed like 2 hours of labor intensive really mentally taxing work to get it to say hello... well you'd find a better way.

This is basically where all coding/programming/anything-tech languages (and a lot of tools) are born. Out of a need to let the human be lazier and just get to the good stuff.

That sounds we're. I'm typing this at 2am. You're telling me developers are lazy? 

Yes. The LAZIEST. But that's actually just abour human DNA's survival programss expressing itself in a mental context. To survive the human is the most efficient at using or storing resources as the environment demands. We adapt to suit it. Eat too much today? No problem, let me store that for you. No food today? No problem, let me convert some storage to fuel!

Developers do the same thing. I dont want to repeat myself when I code. DRY is a thing we do. Because it's easier to handle mentally.

That's another thing. This is all to maintain sanity.

So we have Binary 1s and 0s, Assembly which is only a small step away

Procedural vs. Object Oriented

Client-Side vs. Server-Side

Interpreted vs. Compiled

Syntax vs. Semantics

Presentation vs. Logic

Strict Typing vs. Loose 

Frontend vs. Backend

Java vs. JavaScript

Web Service vs. API

XML vs. HTML

Java is to JavaScript what Frank is to Frankenstein. One probably works in an office, the other in a lab (or cemetary, whatever floats your canoes)

https://en.wikipedia.org/wiki/Programming_paradigm

https://en.wikipedia.org/wiki/Comparison_of_multi-paradigm_programming_languages